package com.example.users.config;

/**
 * Содержимое уроков с подробной теорией
 */
public class LessonContent {
    
    public static final String LESSON_1_CYCLES = """
        # Введение в циклы
        
        ## Что такое циклы?
        
        Циклы позволяют выполнять один и тот же блок кода несколько раз. Это один из основных инструментов программирования, который помогает избежать повторения кода.
        
        ## Типы циклов в C
        
        В языке C существует три типа циклов:
        
        ### 1. Цикл for
        
        Используется когда заранее известно количество итераций.
        
        **Синтаксис:**
        ```c
        for (инициализация; условие; изменение) {
            // код для выполнения
        }
        ```
        
        **Пример:**
        ```c
        for (int i = 0; i < 10; i++) {
            printf("%d\\n", i);
        }
        ```
        
        Этот цикл выведет числа от 0 до 9.
        
        **Как работает:**
        1. Инициализация: `int i = 0` - выполняется один раз в начале
        2. Условие: `i < 10` - проверяется перед каждой итерацией
        3. Тело цикла: выполняется код внутри фигурных скобок
        4. Изменение: `i++` - выполняется после каждой итерации
        5. Возврат к шагу 2
        
        ### 2. Цикл while
        
        Выполняется пока условие истинно (true).
        
        **Синтаксис:**
        ```c
        while (условие) {
            // код для выполнения
        }
        ```
        
        **Пример:**
        ```c
        int i = 0;
        while (i < 10) {
            printf("%d\\n", i);
            i++;
        }
        ```
        
        **Важно:** Не забудьте изменять переменную в условии, иначе цикл будет бесконечным!
        
        ### 3. Цикл do-while
        
        Выполняется хотя бы один раз, затем проверяет условие.
        
        **Синтаксис:**
        ```c
        do {
            // код для выполнения
        } while (условие);
        ```
        
        **Пример:**
        ```c
        int i = 0;
        do {
            printf("%d\\n", i);
            i++;
        } while (i < 10);
        ```
        
        **Отличие от while:** Тело цикла выполнится хотя бы один раз, даже если условие изначально ложно.
        
        ## Вложенные циклы
        
        Циклы можно вкладывать друг в друга:
        
        ```c
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                printf("(%d, %d)\\n", i, j);
            }
        }
        ```
        
        Выведет все пары (0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2).
        
        ## Управление циклами
        
        ### break - выход из цикла
        
        ```c
        for (int i = 0; i < 10; i++) {
            if (i == 5) {
                break; // выходим из цикла
            }
            printf("%d\\n", i);
        }
        ```
        
        Выведет числа от 0 до 4, затем цикл прервется.
        
        ### continue - переход к следующей итерации
        
        ```c
        for (int i = 0; i < 10; i++) {
            if (i % 2 == 0) {
                continue; // пропускаем четные числа
            }
            printf("%d\\n", i);
        }
        ```
        
        Выведет только нечетные числа: 1, 3, 5, 7, 9.
        
        ## Практические примеры
        
        ### Пример 1: Сумма чисел от 1 до N
        
        ```c
        #include <stdio.h>
        
        int main() {
            int n, sum = 0;
            scanf("%d", &n);
            
            for (int i = 1; i <= n; i++) {
                sum += i;
            }
            
            printf("%d\\n", sum);
            return 0;
        }
        ```
        
        ### Пример 2: Таблица умножения
        
        ```c
        #include <stdio.h>
        
        int main() {
            int n;
            scanf("%d", &n);
            
            for (int i = 1; i <= 10; i++) {
                printf("%d x %d = %d\\n", n, i, n * i);
            }
            
            return 0;
        }
        ```
        
        ## Типичные ошибки
        
        1. **Бесконечный цикл:**
        ```c
        int i = 0;
        while (i < 10) {
            printf("%d\\n", i);
            // забыли i++ - цикл никогда не закончится!
        }
        ```
        
        2. **Неправильное условие:**
        ```c
        for (int i = 0; i <= 10; i++) { // будет 11 итераций вместо 10
            printf("%d\\n", i);
        }
        ```
        
        3. **Использование неинициализированной переменной:**
        ```c
        int i;
        while (i < 10) { // i содержит мусор!
            printf("%d\\n", i);
            i++;
        }
        ```
        
        ## Резюме
        
        - Используйте `for` когда известно количество итераций
        - Используйте `while` когда количество итераций неизвестно
        - Используйте `do-while` когда нужно выполнить код хотя бы один раз
        - Всегда проверяйте условие выхода из цикла
        - Используйте `break` для досрочного выхода
        - Используйте `continue` для пропуска итерации
        """;
    
    public static final String LESSON_2_ARRAYS = """
        # Работа с массивами
        
        ## Что такое массив?
        
        Массив - это набор элементов одного типа, расположенных в памяти последовательно. Все элементы массива имеют одинаковый тип данных.
        
        ## Объявление массива
        
        **Синтаксис:**
        ```c
        тип имя[размер];
        ```
        
        **Примеры:**
        ```c
        int numbers[10];        // массив из 10 целых чисел
        float prices[5];       // массив из 5 чисел с плавающей точкой
        char name[20];         // массив из 20 символов
        ```
        
        ## Инициализация массива
        
        Массив можно инициализировать при объявлении:
        
        ```c
        int arr[5] = {1, 2, 3, 4, 5};
        int arr2[] = {10, 20, 30}; // размер определяется автоматически
        int arr3[5] = {1, 2};      // остальные элементы будут 0
        ```
        
        ## Доступ к элементам
        
        **Важно:** Индексация начинается с 0!
        
        ```c
        int arr[5] = {10, 20, 30, 40, 50};
        
        arr[0] = 100;  // первый элемент
        arr[4] = 500;  // последний элемент (индекс = размер - 1)
        
        printf("%d\\n", arr[2]); // выведет 30
        ```
        
        **Осторожно:** Выход за границы массива приводит к неопределенному поведению!
        
        ```c
        int arr[5];
        arr[10] = 100; // ОШИБКА! Выход за границы
        ```
        
        ## Перебор элементов массива
        
        ### С помощью цикла for:
        
        ```c
        int arr[5] = {1, 2, 3, 4, 5};
        
        for (int i = 0; i < 5; i++) {
            printf("%d ", arr[i]);
        }
        // Выведет: 1 2 3 4 5
        ```
        
        ### С помощью цикла while:
        
        ```c
        int arr[5] = {1, 2, 3, 4, 5};
        int i = 0;
        
        while (i < 5) {
            printf("%d ", arr[i]);
            i++;
        }
        ```
        
        ## Операции с массивами
        
        ### Поиск максимального элемента
        
        ```c
        int arr[5] = {3, 7, 2, 9, 1};
        int max = arr[0];
        
        for (int i = 1; i < 5; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        
        printf("Максимум: %d\\n", max); // 9
        ```
        
        ### Сумма элементов
        
        ```c
        int arr[5] = {1, 2, 3, 4, 5};
        int sum = 0;
        
        for (int i = 0; i < 5; i++) {
            sum += arr[i];
        }
        
        printf("Сумма: %d\\n", sum); // 15
        ```
        
        ### Поиск элемента
        
        ```c
        int arr[5] = {10, 20, 30, 40, 50};
        int target = 30;
        int found = -1;
        
        for (int i = 0; i < 5; i++) {
            if (arr[i] == target) {
                found = i;
                break;
            }
        }
        
        if (found != -1) {
            printf("Найдено на позиции %d\\n", found);
        } else {
            printf("Не найдено\\n");
        }
        ```
        
        ## Многомерные массивы
        
        Массивы могут быть многомерными (массивы массивов):
        
        ```c
        int matrix[3][4]; // матрица 3x4
        
        // Инициализация
        int matrix[3][4] = {
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12}
        };
        
        // Доступ к элементу
        matrix[1][2] = 100; // строка 1, столбец 2
        ```
        
        ### Перебор двумерного массива
        
        ```c
        int matrix[3][4] = {
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12}
        };
        
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                printf("%d ", matrix[i][j]);
            }
            printf("\\n");
        }
        ```
        
        ## Массивы и функции
        
        При передаче массива в функцию передается указатель на первый элемент:
        
        ```c
        void printArray(int arr[], int size) {
            for (int i = 0; i < size; i++) {
                printf("%d ", arr[i]);
            }
        }
        
        int main() {
            int arr[5] = {1, 2, 3, 4, 5};
            printArray(arr, 5);
            return 0;
        }
        ```
        
        **Важно:** Размер массива нужно передавать отдельно!
        
        ## Типичные ошибки
        
        1. **Выход за границы:**
        ```c
        int arr[5];
        arr[5] = 10; // ОШИБКА! Последний индекс - 4
        ```
        
        2. **Неинициализированный массив:**
        ```c
        int arr[5];
        printf("%d\\n", arr[0]); // содержит мусор!
        ```
        
        3. **Забыли передать размер:**
        ```c
        void func(int arr[]) {
            for (int i = 0; i < ???; i++) { // размер неизвестен!
            }
        }
        ```
        
        ## Резюме
        
        - Массивы хранят элементы одного типа
        - Индексация начинается с 0
        - Последний индекс = размер - 1
        - Всегда проверяйте границы массива
        - При передаче в функцию нужно передавать размер отдельно
        - Массивы можно использовать для хранения больших объемов данных
        """;
    
    public static final String LESSON_3_FUNCTIONS = """
        # Функции в C
        
        ## Что такое функция?
        
        Функция - это именованный блок кода, который выполняет определенную задачу. Функции помогают:
        - Организовать код
        - Избежать дублирования
        - Упростить отладку и тестирование
        - Повысить читаемость программы
        
        ## Объявление функции
        
        **Синтаксис:**
        ```c
        тип_возвращаемого_значения имя_функции(параметры) {
            // тело функции
            return значение;
        }
        ```
        
        **Пример:**
        ```c
        int add(int a, int b) {
            return a + b;
        }
        ```
        
        ## Типы функций
        
        ### Функция с возвращаемым значением
        
        ```c
        int multiply(int x, int y) {
            return x * y;
        }
        
        int result = multiply(5, 3); // result = 15
        ```
        
        ### Функция без возвращаемого значения (void)
        
        ```c
        void printHello() {
            printf("Hello!\\n");
        }
        
        printHello(); // просто вызов, без присваивания
        ```
        
        ### Функция без параметров
        
        ```c
        int getNumber() {
            return 42;
        }
        
        int num = getNumber();
        ```
        
        ## Параметры функции
        
        Параметры - это переменные, которые функция получает при вызове:
        
        ```c
        void greet(char name[]) {
            printf("Hello, %s!\\n", name);
        }
        
        greet("Alice"); // выведет: Hello, Alice!
        ```
        
        **Важно:** В C параметры передаются по значению (копируются):
        
        ```c
        void changeValue(int x) {
            x = 100; // изменяется только копия
        }
        
        int num = 5;
        changeValue(num);
        printf("%d\\n", num); // все еще 5!
        ```
        
        ## Прототип функции
        
        Прототип - это объявление функции без тела. Позволяет использовать функцию до её определения:
        
        ```c
        // Прототип
        int add(int a, int b);
        
        int main() {
            int result = add(5, 3); // можно использовать
            return 0;
        }
        
        // Определение
        int add(int a, int b) {
            return a + b;
        }
        ```
        
        ## Рекурсия
        
        Функция может вызывать саму себя - это называется рекурсией:
        
        ```c
        int factorial(int n) {
            if (n <= 1) {
                return 1;
            }
            return n * factorial(n - 1);
        }
        
        int result = factorial(5); // 120
        ```
        
        **Как работает:**
        - factorial(5) = 5 * factorial(4)
        - factorial(4) = 4 * factorial(3)
        - factorial(3) = 3 * factorial(2)
        - factorial(2) = 2 * factorial(1)
        - factorial(1) = 1
        - Результат: 5 * 4 * 3 * 2 * 1 = 120
        
        **Важно:** Всегда должно быть условие выхода, иначе рекурсия будет бесконечной!
        
        ## Область видимости переменных
        
        ### Локальные переменные
        
        Переменные, объявленные внутри функции, видны только в этой функции:
        
        ```c
        void func() {
            int x = 10; // локальная переменная
            printf("%d\\n", x);
        }
        
        int main() {
            // printf("%d\\n", x); // ОШИБКА! x не видна здесь
            return 0;
        }
        ```
        
        ### Глобальные переменные
        
        Переменные, объявленные вне функций, видны везде:
        
        ```c
        int global = 100; // глобальная переменная
        
        void func() {
            printf("%d\\n", global); // можно использовать
        }
        
        int main() {
            printf("%d\\n", global); // можно использовать
            return 0;
        }
        ```
        
        ## Практические примеры
        
        ### Пример 1: Проверка на простое число
        
        ```c
        int isPrime(int n) {
            if (n < 2) return 0;
            
            for (int i = 2; i * i <= n; i++) {
                if (n % i == 0) {
                    return 0; // не простое
                }
            }
            return 1; // простое
        }
        
        int main() {
            int num = 17;
            if (isPrime(num)) {
                printf("%d - простое число\\n", num);
            }
            return 0;
        }
        ```
        
        ### Пример 2: Возведение в степень
        
        ```c
        int power(int base, int exponent) {
            int result = 1;
            for (int i = 0; i < exponent; i++) {
                result *= base;
            }
            return result;
        }
        
        int main() {
            int result = power(2, 3); // 2^3 = 8
            printf("%d\\n", result);
            return 0;
        }
        ```
        
        ### Пример 3: Поиск максимума в массиве
        
        ```c
        int findMax(int arr[], int size) {
            int max = arr[0];
            for (int i = 1; i < size; i++) {
                if (arr[i] > max) {
                    max = arr[i];
                }
            }
            return max;
        }
        
        int main() {
            int arr[5] = {3, 7, 2, 9, 1};
            int max = findMax(arr, 5);
            printf("Максимум: %d\\n", max);
            return 0;
        }
        ```
        
        ## Типичные ошибки
        
        1. **Забыли return:**
        ```c
        int add(int a, int b) {
            a + b; // ОШИБКА! Нет return
        }
        ```
        
        2. **Неправильный тип возвращаемого значения:**
        ```c
        int func() {
            return 3.14; // потеря точности!
        }
        ```
        
        3. **Использование неинициализированных параметров:**
        ```c
        int func(int x) {
            return x + y; // y не объявлена!
        }
        ```
        
        ## Резюме
        
        - Функции помогают организовать код
        - Параметры передаются по значению (копируются)
        - Всегда указывайте тип возвращаемого значения
        - Используйте прототипы для объявления функций
        - Рекурсия полезна, но требует условия выхода
        - Локальные переменные видны только в функции
        - Глобальные переменные видны везде (используйте осторожно!)
        """;
    
    public static final String LESSON_4_POINTERS = """
        # Указатели в C
        
        ## Что такое указатель?
        
        Указатель - это переменная, которая хранит адрес другой переменной в памяти. Указатели - одна из самых мощных и сложных особенностей языка C.
        
        ## Зачем нужны указатели?
        
        - Прямой доступ к памяти
        - Эффективная передача данных в функции
        - Работа с динамической памятью
        - Создание сложных структур данных
        
        ## Объявление указателя
        
        **Синтаксис:**
        ```c
        тип *имя_указателя;
        ```
        
        **Примеры:**
        ```c
        int *ptr;      // указатель на int
        float *fptr;   // указатель на float
        char *cptr;    // указатель на char
        ```
        
        **Важно:** Звездочка (*) может быть рядом с типом или с именем:
        ```c
        int* ptr;  // тоже правильно
        int * ptr; // тоже правильно
        ```
        
        ## Операторы указателей
        
        ### & - оператор адреса
        
        Получает адрес переменной:
        
        ```c
        int x = 10;
        int *ptr = &x; // ptr теперь содержит адрес x
        
        printf("Адрес x: %p\\n", &x);
        printf("Значение ptr: %p\\n", ptr); // тот же адрес
        ```
        
        ### * - оператор разыменования
        
        Получает значение по адресу:
        
        ```c
        int x = 10;
        int *ptr = &x;
        
        printf("x = %d\\n", x);        // 10
        printf("*ptr = %d\\n", *ptr);  // 10 (значение по адресу)
        
        *ptr = 20; // изменяем значение x через указатель
        printf("x = %d\\n", x);        // 20
        ```
        
        ## Указатели и функции
        
        Указатели позволяют изменять переменные внутри функций:
        
        ```c
        void swap(int *a, int *b) {
            int temp = *a;
            *a = *b;
            *b = temp;
        }
        
        int main() {
            int x = 5, y = 10;
            swap(&x, &y);
            printf("x = %d, y = %d\\n", x, y); // x = 10, y = 5
            return 0;
        }
        ```
        
        **Без указателей это не сработает:**
        ```c
        void swap(int a, int b) { // копии, не оригиналы!
            int temp = a;
            a = b;
            b = temp;
        }
        // x и y не изменятся!
        ```
        
        ## Указатели и массивы
        
        Имя массива - это указатель на первый элемент:
        
        ```c
        int arr[5] = {1, 2, 3, 4, 5};
        int *ptr = arr; // ptr указывает на arr[0]
        
        printf("%d\\n", *ptr);      // 1 (первый элемент)
        printf("%d\\n", *(ptr+1)); // 2 (второй элемент)
        printf("%d\\n", ptr[2]);   // 3 (третий элемент)
        ```
        
        **Арифметика указателей:**
        ```c
        int arr[5] = {10, 20, 30, 40, 50};
        int *ptr = arr;
        
        ptr++;        // теперь указывает на arr[1]
        ptr += 2;     // теперь указывает на arr[3]
        ptr--;        // теперь указывает на arr[2]
        ```
        
        ## Динамическая память
        
        ### malloc - выделение памяти
        
        ```c
        #include <stdlib.h>
        
        int *arr = (int*)malloc(5 * sizeof(int)); // массив из 5 int
        
        if (arr == NULL) {
            printf("Ошибка выделения памяти!\\n");
            return 1;
        }
        
        // Использование
        for (int i = 0; i < 5; i++) {
            arr[i] = i * 10;
        }
        
        // ОБЯЗАТЕЛЬНО освободить память!
        free(arr);
        ```
        
        ### calloc - выделение с обнулением
        
        ```c
        int *arr = (int*)calloc(5, sizeof(int));
        // все элементы инициализированы нулями
        free(arr);
        ```
        
        ### realloc - изменение размера
        
        ```c
        int *arr = (int*)malloc(5 * sizeof(int));
        arr = (int*)realloc(arr, 10 * sizeof(int)); // увеличили размер
        free(arr);
        ```
        
        **Важно:** Всегда проверяйте результат malloc/calloc/realloc на NULL!
        
        ## Указатель на указатель
        
        Можно создавать указатели на указатели:
        
        ```c
        int x = 10;
        int *ptr = &x;
        int **pptr = &ptr; // указатель на указатель
        
        printf("%d\\n", **pptr); // 10
        ```
        
        ## NULL указатель
        
        NULL - специальное значение, означающее "ничего не указывает":
        
        ```c
        int *ptr = NULL;
        
        if (ptr == NULL) {
            printf("Указатель не инициализирован\\n");
        }
        
        // ОШИБКА! Разыменование NULL указателя
        // *ptr = 10; // приведет к краху программы
        ```
        
        **Всегда инициализируйте указатели!**
        
        ## Практические примеры
        
        ### Пример 1: Обмен значений
        
        ```c
        void swap(int *a, int *b) {
            int temp = *a;
            *a = *b;
            *b = temp;
        }
        
        int main() {
            int x = 5, y = 10;
            swap(&x, &y);
            printf("x = %d, y = %d\\n", x, y);
            return 0;
        }
        ```
        
        ### Пример 2: Динамический массив
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        int main() {
            int n;
            scanf("%d", &n);
            
            int *arr = (int*)malloc(n * sizeof(int));
            if (arr == NULL) {
                printf("Ошибка!\\n");
                return 1;
            }
            
            for (int i = 0; i < n; i++) {
                arr[i] = i * 2;
            }
            
            for (int i = 0; i < n; i++) {
                printf("%d ", arr[i]);
            }
            
            free(arr);
            return 0;
        }
        ```
        
        ## Типичные ошибки
        
        1. **Разыменование неинициализированного указателя:**
        ```c
        int *ptr;
        *ptr = 10; // ОШИБКА! ptr содержит мусор
        ```
        
        2. **Утечка памяти:**
        ```c
        int *arr = malloc(100 * sizeof(int));
        // забыли free(arr) - утечка памяти!
        ```
        
        3. **Двойное освобождение:**
        ```c
        int *arr = malloc(100 * sizeof(int));
        free(arr);
        free(arr); // ОШИБКА! Память уже освобождена
        ```
        
        4. **Использование после освобождения:**
        ```c
        int *arr = malloc(100 * sizeof(int));
        free(arr);
        arr[0] = 10; // ОШИБКА! Память уже освобождена
        ```
        
        ## Резюме
        
        - Указатель хранит адрес переменной
        - & получает адрес, * разыменовывает
        - Указатели позволяют изменять переменные в функциях
        - Имя массива - указатель на первый элемент
        - malloc выделяет память, free освобождает
        - Всегда проверяйте указатели на NULL
        - Всегда освобождайте выделенную память
        - Указатели - мощный инструмент, но требуют осторожности!
        """;
    
    public static final String LESSON_5_STRINGS = """
        # Работа со строками в C
        
        ## Что такое строка?
        
        В C строка - это массив символов, заканчивающийся нулевым символом `\\0` (null terminator). Это не отдельный тип данных!
        
        ## Объявление строк
        
        ### Способ 1: Массив символов
        
        ```c
        char str[20] = "Hello";
        // Автоматически добавляется '\\0' в конец
        ```
        
        ### Способ 2: Указатель на строковый литерал
        
        ```c
        char *str = "Hello";
        // Строковые литералы неизменяемы!
        ```
        
        ### Способ 3: Инициализация посимвольно
        
        ```c
        char str[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};
        ```
        
        **Важно:** Не забудьте `\\0` в конце!
        
        ## Ввод и вывод строк
        
        ### printf и scanf
        
        ```c
        char name[50];
        printf("Введите имя: ");
        scanf("%s", name); // читает до пробела
        printf("Привет, %s!\\n", name);
        ```
        
        ### gets и puts (устаревшие, не рекомендуется)
        
        ```c
        char str[100];
        gets(str);  // читает всю строку (опасно!)
        puts(str);  // выводит строку с переводом строки
        ```
        
        ### fgets - безопасный ввод
        
        ```c
        char str[100];
        fgets(str, 100, stdin); // читает максимум 99 символов
        printf("%s", str);
        ```
        
        ## Стандартные функции для работы со строками
        
        Все функции находятся в `<string.h>`:
        
        ### strlen - длина строки
        
        ```c
        #include <string.h>
        
        char str[] = "Hello";
        int len = strlen(str); // 5 (без учета '\\0')
        ```
        
        ### strcpy - копирование
        
        ```c
        char src[] = "Hello";
        char dest[20];
        
        strcpy(dest, src); // копирует src в dest
        printf("%s\\n", dest); // Hello
        ```
        
        **Осторожно:** strcpy не проверяет размер! Используйте strncpy:
        ```c
        strncpy(dest, src, 19);
        dest[19] = '\\0'; // гарантируем завершение
        ```
        
        ### strcat - конкатенация (объединение)
        
        ```c
        char str1[20] = "Hello";
        char str2[] = " World";
        
        strcat(str1, str2);
        printf("%s\\n", str1); // Hello World
        ```
        
        ### strcmp - сравнение
        
        ```c
        char str1[] = "apple";
        char str2[] = "banana";
        
        int result = strcmp(str1, str2);
        // result < 0 если str1 < str2
        // result == 0 если str1 == str2
        // result > 0 если str1 > str2
        ```
        
        ### strchr - поиск символа
        
        ```c
        char str[] = "Hello";
        char *ptr = strchr(str, 'l'); // ищет первое вхождение 'l'
        
        if (ptr != NULL) {
            printf("Найдено на позиции %ld\\n", ptr - str); // 2
        }
        ```
        
        ### strstr - поиск подстроки
        
        ```c
        char str[] = "Hello World";
        char *ptr = strstr(str, "World");
        
        if (ptr != NULL) {
            printf("Найдено: %s\\n", ptr); // World
        }
        ```
        
        ## Создание собственных функций
        
        ### Длина строки (без strlen)
        
        ```c
        int myStrlen(char str[]) {
            int len = 0;
            while (str[len] != '\\0') {
                len++;
            }
            return len;
        }
        ```
        
        ### Копирование (без strcpy)
        
        ```c
        void myStrcpy(char dest[], char src[]) {
            int i = 0;
            while (src[i] != '\\0') {
                dest[i] = src[i];
                i++;
            }
            dest[i] = '\\0';
        }
        ```
        
        ### Объединение (без strcat)
        
        ```c
        void myStrcat(char dest[], char src[]) {
            int len = 0;
            while (dest[len] != '\\0') {
                len++;
            }
            
            int i = 0;
            while (src[i] != '\\0') {
                dest[len + i] = src[i];
                i++;
            }
            dest[len + i] = '\\0';
        }
        ```
        
        ## Перебор символов строки
        
        ```c
        char str[] = "Hello";
        
        // Способ 1: по индексу
        for (int i = 0; str[i] != '\\0'; i++) {
            printf("%c ", str[i]);
        }
        
        // Способ 2: через указатель
        char *ptr = str;
        while (*ptr != '\\0') {
            printf("%c ", *ptr);
            ptr++;
        }
        ```
        
        ## Модификация строк
        
        ```c
        char str[] = "Hello";
        
        str[0] = 'h'; // изменяем первый символ
        printf("%s\\n", str); // hello
        
        // Строковые литералы неизменяемы!
        char *ptr = "Hello";
        // ptr[0] = 'h'; // ОШИБКА! Приведет к краху
        ```
        
        ## Практические примеры
        
        ### Пример 1: Подсчет символов
        
        ```c
        #include <stdio.h>
        
        int countChars(char str[]) {
            int count = 0;
            while (str[count] != '\\0') {
                count++;
            }
            return count;
        }
        
        int main() {
            char str[] = "Hello";
            printf("Длина: %d\\n", countChars(str));
            return 0;
        }
        ```
        
        ### Пример 2: Поиск подстроки
        
        ```c
        int findSubstring(char str[], char substr[]) {
            int i = 0, j = 0;
            
            while (str[i] != '\\0') {
                if (str[i] == substr[j]) {
                    j++;
                    if (substr[j] == '\\0') {
                        return i - j + 1; // найдено
                    }
                } else {
                    j = 0;
                }
                i++;
            }
            return -1; // не найдено
        }
        ```
        
        ### Пример 3: Реверс строки
        
        ```c
        void reverseString(char str[]) {
            int len = 0;
            while (str[len] != '\\0') {
                len++;
            }
            
            for (int i = 0; i < len / 2; i++) {
                char temp = str[i];
                str[i] = str[len - 1 - i];
                str[len - 1 - i] = temp;
            }
        }
        ```
        
        ## Типичные ошибки
        
        1. **Забыли '\\0':**
        ```c
        char str[5] = {'H', 'e', 'l', 'l', 'o'}; // нет '\\0'!
        printf("%s\\n", str); // может вывести мусор
        ```
        
        2. **Выход за границы:**
        ```c
        char str[5] = "Hello"; // ОШИБКА! Нет места для '\\0'
        ```
        
        3. **Использование небезопасных функций:**
        ```c
        char str[10];
        gets(str); // ОПАСНО! Может переполнить буфер
        ```
        
        4. **Сравнение через ==:**
        ```c
        char str1[] = "Hello";
        char str2[] = "Hello";
        if (str1 == str2) { // ОШИБКА! Сравнивает адреса, не содержимое
        }
        // Правильно: if (strcmp(str1, str2) == 0)
        ```
        
        ## Резюме
        
        - Строка - массив символов с '\\0' в конце
        - strlen возвращает длину без '\\0'
        - strcpy копирует, strcat объединяет
        - strcmp сравнивает строки
        - Всегда оставляйте место для '\\0'
        - Используйте безопасные функции (fgets вместо gets)
        - Строковые литералы неизменяемы
        - Для сравнения используйте strcmp, не ==
        """;
}

