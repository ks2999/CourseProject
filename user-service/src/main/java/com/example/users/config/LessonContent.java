package com.example.users.config;

/**
 * Содержимое уроков с подробной теорией
 */
public class LessonContent {
    
    public static final String LESSON_1_CYCLES = """
        # Введение в циклы
        
        ## Что такое циклы?
        
        Циклы позволяют выполнять один и тот же блок кода несколько раз. Это один из основных инструментов программирования, который помогает избежать повторения кода.
        
        ## Типы циклов в C
        
        В языке C существует три типа циклов:
        
        ### 1. Цикл for
        
        Используется когда заранее известно количество итераций.
        
        **Синтаксис:**
        ```c
        for (инициализация; условие; изменение) {
            // код для выполнения
        }
        ```
        
        **Пример:**
        ```c
        for (int i = 0; i < 10; i++) {
            printf("%d\\n", i);
        }
        ```
        
        Этот цикл выведет числа от 0 до 9.
        
        **Как работает:**
        1. Инициализация: `int i = 0` - выполняется один раз в начале
        2. Условие: `i < 10` - проверяется перед каждой итерацией
        3. Тело цикла: выполняется код внутри фигурных скобок
        4. Изменение: `i++` - выполняется после каждой итерации
        5. Возврат к шагу 2
        
        ### 2. Цикл while
        
        Выполняется пока условие истинно (true).
        
        **Синтаксис:**
        ```c
        while (условие) {
            // код для выполнения
        }
        ```
        
        **Пример:**
        ```c
        int i = 0;
        while (i < 10) {
            printf("%d\\n", i);
            i++;
        }
        ```
        
        **Важно:** Не забудьте изменять переменную в условии, иначе цикл будет бесконечным!
        
        ### 3. Цикл do-while
        
        Выполняется хотя бы один раз, затем проверяет условие.
        
        **Синтаксис:**
        ```c
        do {
            // код для выполнения
        } while (условие);
        ```
        
        **Пример:**
        ```c
        int i = 0;
        do {
            printf("%d\\n", i);
            i++;
        } while (i < 10);
        ```
        
        **Отличие от while:** Тело цикла выполнится хотя бы один раз, даже если условие изначально ложно.
        
        ## Вложенные циклы
        
        Циклы можно вкладывать друг в друга:
        
        ```c
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                printf("(%d, %d)\\n", i, j);
            }
        }
        ```
        
        Выведет все пары (0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0), (2,1), (2,2).
        
        ## Управление циклами
        
        ### break - выход из цикла
        
        ```c
        for (int i = 0; i < 10; i++) {
            if (i == 5) {
                break; // выходим из цикла
            }
            printf("%d\\n", i);
        }
        ```
        
        Выведет числа от 0 до 4, затем цикл прервется.
        
        ### continue - переход к следующей итерации
        
        ```c
        for (int i = 0; i < 10; i++) {
            if (i % 2 == 0) {
                continue; // пропускаем четные числа
            }
            printf("%d\\n", i);
        }
        ```
        
        Выведет только нечетные числа: 1, 3, 5, 7, 9.
        
        ## Практические примеры
        
        ### Пример 1: Сумма чисел от 1 до N
        
        ```c
        #include <stdio.h>
        
        int main() {
            int n, sum = 0;
            scanf("%d", &n);
            
            for (int i = 1; i <= n; i++) {
                sum += i;
            }
            
            printf("%d\\n", sum);
            return 0;
        }
        ```
        
        ### Пример 2: Таблица умножения
        
        ```c
        #include <stdio.h>
        
        int main() {
            int n;
            scanf("%d", &n);
            
            for (int i = 1; i <= 10; i++) {
                printf("%d x %d = %d\\n", n, i, n * i);
            }
            
            return 0;
        }
        ```
        
        ## Типичные ошибки
        
        1. **Бесконечный цикл:**
        ```c
        int i = 0;
        while (i < 10) {
            printf("%d\\n", i);
            // забыли i++ - цикл никогда не закончится!
        }
        ```
        
        2. **Неправильное условие:**
        ```c
        for (int i = 0; i <= 10; i++) { // будет 11 итераций вместо 10
            printf("%d\\n", i);
        }
        ```
        
        3. **Использование неинициализированной переменной:**
        ```c
        int i;
        while (i < 10) { // i содержит мусор!
            printf("%d\\n", i);
            i++;
        }
        ```
        
        ## Резюме
        
        - Используйте `for` когда известно количество итераций
        - Используйте `while` когда количество итераций неизвестно
        - Используйте `do-while` когда нужно выполнить код хотя бы один раз
        - Всегда проверяйте условие выхода из цикла
        - Используйте `break` для досрочного выхода
        - Используйте `continue` для пропуска итерации
        """;
    
    public static final String LESSON_2_ARRAYS = """
        # Работа с массивами
        
        ## Что такое массив?
        
        Массив - это набор элементов одного типа, расположенных в памяти последовательно. Все элементы массива имеют одинаковый тип данных.
        
        ## Объявление массива
        
        **Синтаксис:**
        ```c
        тип имя[размер];
        ```
        
        **Примеры:**
        ```c
        int numbers[10];        // массив из 10 целых чисел
        float prices[5];       // массив из 5 чисел с плавающей точкой
        char name[20];         // массив из 20 символов
        ```
        
        ## Инициализация массива
        
        Массив можно инициализировать при объявлении:
        
        ```c
        int arr[5] = {1, 2, 3, 4, 5};
        int arr2[] = {10, 20, 30}; // размер определяется автоматически
        int arr3[5] = {1, 2};      // остальные элементы будут 0
        ```
        
        ## Доступ к элементам
        
        **Важно:** Индексация начинается с 0!
        
        ```c
        int arr[5] = {10, 20, 30, 40, 50};
        
        arr[0] = 100;  // первый элемент
        arr[4] = 500;  // последний элемент (индекс = размер - 1)
        
        printf("%d\\n", arr[2]); // выведет 30
        ```
        
        **Осторожно:** Выход за границы массива приводит к неопределенному поведению!
        
        ```c
        int arr[5];
        arr[10] = 100; // ОШИБКА! Выход за границы
        ```
        
        ## Перебор элементов массива
        
        ### С помощью цикла for:
        
        ```c
        int arr[5] = {1, 2, 3, 4, 5};
        
        for (int i = 0; i < 5; i++) {
            printf("%d ", arr[i]);
        }
        // Выведет: 1 2 3 4 5
        ```
        
        ### С помощью цикла while:
        
        ```c
        int arr[5] = {1, 2, 3, 4, 5};
        int i = 0;
        
        while (i < 5) {
            printf("%d ", arr[i]);
            i++;
        }
        ```
        
        ## Операции с массивами
        
        ### Поиск максимального элемента
        
        ```c
        int arr[5] = {3, 7, 2, 9, 1};
        int max = arr[0];
        
        for (int i = 1; i < 5; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        
        printf("Максимум: %d\\n", max); // 9
        ```
        
        ### Сумма элементов
        
        ```c
        int arr[5] = {1, 2, 3, 4, 5};
        int sum = 0;
        
        for (int i = 0; i < 5; i++) {
            sum += arr[i];
        }
        
        printf("Сумма: %d\\n", sum); // 15
        ```
        
        ### Поиск элемента
        
        ```c
        int arr[5] = {10, 20, 30, 40, 50};
        int target = 30;
        int found = -1;
        
        for (int i = 0; i < 5; i++) {
            if (arr[i] == target) {
                found = i;
                break;
            }
        }
        
        if (found != -1) {
            printf("Найдено на позиции %d\\n", found);
        } else {
            printf("Не найдено\\n");
        }
        ```
        
        ## Многомерные массивы
        
        Массивы могут быть многомерными (массивы массивов):
        
        ```c
        int matrix[3][4]; // матрица 3x4
        
        // Инициализация
        int matrix[3][4] = {
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12}
        };
        
        // Доступ к элементу
        matrix[1][2] = 100; // строка 1, столбец 2
        ```
        
        ### Перебор двумерного массива
        
        ```c
        int matrix[3][4] = {
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12}
        };
        
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                printf("%d ", matrix[i][j]);
            }
            printf("\\n");
        }
        ```
        
        ## Массивы и функции
        
        При передаче массива в функцию передается указатель на первый элемент:
        
        ```c
        void printArray(int arr[], int size) {
            for (int i = 0; i < size; i++) {
                printf("%d ", arr[i]);
            }
        }
        
        int main() {
            int arr[5] = {1, 2, 3, 4, 5};
            printArray(arr, 5);
            return 0;
        }
        ```
        
        **Важно:** Размер массива нужно передавать отдельно!
        
        ## Типичные ошибки
        
        1. **Выход за границы:**
        ```c
        int arr[5];
        arr[5] = 10; // ОШИБКА! Последний индекс - 4
        ```
        
        2. **Неинициализированный массив:**
        ```c
        int arr[5];
        printf("%d\\n", arr[0]); // содержит мусор!
        ```
        
        3. **Забыли передать размер:**
        ```c
        void func(int arr[]) {
            for (int i = 0; i < ???; i++) { // размер неизвестен!
            }
        }
        ```
        
        ## Резюме
        
        - Массивы хранят элементы одного типа
        - Индексация начинается с 0
        - Последний индекс = размер - 1
        - Всегда проверяйте границы массива
        - При передаче в функцию нужно передавать размер отдельно
        - Массивы можно использовать для хранения больших объемов данных
        """;
    
    public static final String LESSON_3_FUNCTIONS = """
        # Функции в C
        
        ## Что такое функция?
        
        Функция - это именованный блок кода, который выполняет определенную задачу. Функции помогают:
        - Организовать код
        - Избежать дублирования
        - Упростить отладку и тестирование
        - Повысить читаемость программы
        
        ## Объявление функции
        
        **Синтаксис:**
        ```c
        тип_возвращаемого_значения имя_функции(параметры) {
            // тело функции
            return значение;
        }
        ```
        
        **Пример:**
        ```c
        int add(int a, int b) {
            return a + b;
        }
        ```
        
        ## Типы функций
        
        ### Функция с возвращаемым значением
        
        ```c
        int multiply(int x, int y) {
            return x * y;
        }
        
        int result = multiply(5, 3); // result = 15
        ```
        
        ### Функция без возвращаемого значения (void)
        
        ```c
        void printHello() {
            printf("Hello!\\n");
        }
        
        printHello(); // просто вызов, без присваивания
        ```
        
        ### Функция без параметров
        
        ```c
        int getNumber() {
            return 42;
        }
        
        int num = getNumber();
        ```
        
        ## Параметры функции
        
        Параметры - это переменные, которые функция получает при вызове:
        
        ```c
        void greet(char name[]) {
            printf("Hello, %s!\\n", name);
        }
        
        greet("Alice"); // выведет: Hello, Alice!
        ```
        
        **Важно:** В C параметры передаются по значению (копируются):
        
        ```c
        void changeValue(int x) {
            x = 100; // изменяется только копия
        }
        
        int num = 5;
        changeValue(num);
        printf("%d\\n", num); // все еще 5!
        ```
        
        ## Прототип функции
        
        Прототип - это объявление функции без тела. Позволяет использовать функцию до её определения:
        
        ```c
        // Прототип
        int add(int a, int b);
        
        int main() {
            int result = add(5, 3); // можно использовать
            return 0;
        }
        
        // Определение
        int add(int a, int b) {
            return a + b;
        }
        ```
        
        ## Рекурсия
        
        Функция может вызывать саму себя - это называется рекурсией:
        
        ```c
        int factorial(int n) {
            if (n <= 1) {
                return 1;
            }
            return n * factorial(n - 1);
        }
        
        int result = factorial(5); // 120
        ```
        
        **Как работает:**
        - factorial(5) = 5 * factorial(4)
        - factorial(4) = 4 * factorial(3)
        - factorial(3) = 3 * factorial(2)
        - factorial(2) = 2 * factorial(1)
        - factorial(1) = 1
        - Результат: 5 * 4 * 3 * 2 * 1 = 120
        
        **Важно:** Всегда должно быть условие выхода, иначе рекурсия будет бесконечной!
        
        ## Область видимости переменных
        
        ### Локальные переменные
        
        Переменные, объявленные внутри функции, видны только в этой функции:
        
        ```c
        void func() {
            int x = 10; // локальная переменная
            printf("%d\\n", x);
        }
        
        int main() {
            // printf("%d\\n", x); // ОШИБКА! x не видна здесь
            return 0;
        }
        ```
        
        ### Глобальные переменные
        
        Переменные, объявленные вне функций, видны везде:
        
        ```c
        int global = 100; // глобальная переменная
        
        void func() {
            printf("%d\\n", global); // можно использовать
        }
        
        int main() {
            printf("%d\\n", global); // можно использовать
            return 0;
        }
        ```
        
        ## Практические примеры
        
        ### Пример 1: Проверка на простое число
        
        ```c
        int isPrime(int n) {
            if (n < 2) return 0;
            
            for (int i = 2; i * i <= n; i++) {
                if (n % i == 0) {
                    return 0; // не простое
                }
            }
            return 1; // простое
        }
        
        int main() {
            int num = 17;
            if (isPrime(num)) {
                printf("%d - простое число\\n", num);
            }
            return 0;
        }
        ```
        
        ### Пример 2: Возведение в степень
        
        ```c
        int power(int base, int exponent) {
            int result = 1;
            for (int i = 0; i < exponent; i++) {
                result *= base;
            }
            return result;
        }
        
        int main() {
            int result = power(2, 3); // 2^3 = 8
            printf("%d\\n", result);
            return 0;
        }
        ```
        
        ### Пример 3: Поиск максимума в массиве
        
        ```c
        int findMax(int arr[], int size) {
            int max = arr[0];
            for (int i = 1; i < size; i++) {
                if (arr[i] > max) {
                    max = arr[i];
                }
            }
            return max;
        }
        
        int main() {
            int arr[5] = {3, 7, 2, 9, 1};
            int max = findMax(arr, 5);
            printf("Максимум: %d\\n", max);
            return 0;
        }
        ```
        
        ## Типичные ошибки
        
        1. **Забыли return:**
        ```c
        int add(int a, int b) {
            a + b; // ОШИБКА! Нет return
        }
        ```
        
        2. **Неправильный тип возвращаемого значения:**
        ```c
        int func() {
            return 3.14; // потеря точности!
        }
        ```
        
        3. **Использование неинициализированных параметров:**
        ```c
        int func(int x) {
            return x + y; // y не объявлена!
        }
        ```
        
        ## Резюме
        
        - Функции помогают организовать код
        - Параметры передаются по значению (копируются)
        - Всегда указывайте тип возвращаемого значения
        - Используйте прототипы для объявления функций
        - Рекурсия полезна, но требует условия выхода
        - Локальные переменные видны только в функции
        - Глобальные переменные видны везде (используйте осторожно!)
        """;
    
    public static final String LESSON_4_POINTERS = """
        # Указатели в C
        
        ## Что такое указатель?
        
        Указатель - это переменная, которая хранит адрес другой переменной в памяти. Указатели - одна из самых мощных и сложных особенностей языка C.
        
        ## Зачем нужны указатели?
        
        - Прямой доступ к памяти
        - Эффективная передача данных в функции
        - Работа с динамической памятью
        - Создание сложных структур данных
        
        ## Объявление указателя
        
        **Синтаксис:**
        ```c
        тип *имя_указателя;
        ```
        
        **Примеры:**
        ```c
        int *ptr;      // указатель на int
        float *fptr;   // указатель на float
        char *cptr;    // указатель на char
        ```
        
        **Важно:** Звездочка (*) может быть рядом с типом или с именем:
        ```c
        int* ptr;  // тоже правильно
        int * ptr; // тоже правильно
        ```
        
        ## Операторы указателей
        
        ### & - оператор адреса
        
        Получает адрес переменной:
        
        ```c
        int x = 10;
        int *ptr = &x; // ptr теперь содержит адрес x
        
        printf("Адрес x: %p\\n", &x);
        printf("Значение ptr: %p\\n", ptr); // тот же адрес
        ```
        
        ### * - оператор разыменования
        
        Получает значение по адресу:
        
        ```c
        int x = 10;
        int *ptr = &x;
        
        printf("x = %d\\n", x);        // 10
        printf("*ptr = %d\\n", *ptr);  // 10 (значение по адресу)
        
        *ptr = 20; // изменяем значение x через указатель
        printf("x = %d\\n", x);        // 20
        ```
        
        ## Указатели и функции
        
        Указатели позволяют изменять переменные внутри функций:
        
        ```c
        void swap(int *a, int *b) {
            int temp = *a;
            *a = *b;
            *b = temp;
        }
        
        int main() {
            int x = 5, y = 10;
            swap(&x, &y);
            printf("x = %d, y = %d\\n", x, y); // x = 10, y = 5
            return 0;
        }
        ```
        
        **Без указателей это не сработает:**
        ```c
        void swap(int a, int b) { // копии, не оригиналы!
            int temp = a;
            a = b;
            b = temp;
        }
        // x и y не изменятся!
        ```
        
        ## Указатели и массивы
        
        Имя массива - это указатель на первый элемент:
        
        ```c
        int arr[5] = {1, 2, 3, 4, 5};
        int *ptr = arr; // ptr указывает на arr[0]
        
        printf("%d\\n", *ptr);      // 1 (первый элемент)
        printf("%d\\n", *(ptr+1)); // 2 (второй элемент)
        printf("%d\\n", ptr[2]);   // 3 (третий элемент)
        ```
        
        **Арифметика указателей:**
        ```c
        int arr[5] = {10, 20, 30, 40, 50};
        int *ptr = arr;
        
        ptr++;        // теперь указывает на arr[1]
        ptr += 2;     // теперь указывает на arr[3]
        ptr--;        // теперь указывает на arr[2]
        ```
        
        ## Динамическая память
        
        ### malloc - выделение памяти
        
        ```c
        #include <stdlib.h>
        
        int *arr = (int*)malloc(5 * sizeof(int)); // массив из 5 int
        
        if (arr == NULL) {
            printf("Ошибка выделения памяти!\\n");
            return 1;
        }
        
        // Использование
        for (int i = 0; i < 5; i++) {
            arr[i] = i * 10;
        }
        
        // ОБЯЗАТЕЛЬНО освободить память!
        free(arr);
        ```
        
        ### calloc - выделение с обнулением
        
        ```c
        int *arr = (int*)calloc(5, sizeof(int));
        // все элементы инициализированы нулями
        free(arr);
        ```
        
        ### realloc - изменение размера
        
        ```c
        int *arr = (int*)malloc(5 * sizeof(int));
        arr = (int*)realloc(arr, 10 * sizeof(int)); // увеличили размер
        free(arr);
        ```
        
        **Важно:** Всегда проверяйте результат malloc/calloc/realloc на NULL!
        
        ## Указатель на указатель
        
        Можно создавать указатели на указатели:
        
        ```c
        int x = 10;
        int *ptr = &x;
        int **pptr = &ptr; // указатель на указатель
        
        printf("%d\\n", **pptr); // 10
        ```
        
        ## NULL указатель
        
        NULL - специальное значение, означающее "ничего не указывает":
        
        ```c
        int *ptr = NULL;
        
        if (ptr == NULL) {
            printf("Указатель не инициализирован\\n");
        }
        
        // ОШИБКА! Разыменование NULL указателя
        // *ptr = 10; // приведет к краху программы
        ```
        
        **Всегда инициализируйте указатели!**
        
        ## Практические примеры
        
        ### Пример 1: Обмен значений
        
        ```c
        void swap(int *a, int *b) {
            int temp = *a;
            *a = *b;
            *b = temp;
        }
        
        int main() {
            int x = 5, y = 10;
            swap(&x, &y);
            printf("x = %d, y = %d\\n", x, y);
            return 0;
        }
        ```
        
        ### Пример 2: Динамический массив
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        
        int main() {
            int n;
            scanf("%d", &n);
            
            int *arr = (int*)malloc(n * sizeof(int));
            if (arr == NULL) {
                printf("Ошибка!\\n");
                return 1;
            }
            
            for (int i = 0; i < n; i++) {
                arr[i] = i * 2;
            }
            
            for (int i = 0; i < n; i++) {
                printf("%d ", arr[i]);
            }
            
            free(arr);
            return 0;
        }
        ```
        
        ## Типичные ошибки
        
        1. **Разыменование неинициализированного указателя:**
        ```c
        int *ptr;
        *ptr = 10; // ОШИБКА! ptr содержит мусор
        ```
        
        2. **Утечка памяти:**
        ```c
        int *arr = malloc(100 * sizeof(int));
        // забыли free(arr) - утечка памяти!
        ```
        
        3. **Двойное освобождение:**
        ```c
        int *arr = malloc(100 * sizeof(int));
        free(arr);
        free(arr); // ОШИБКА! Память уже освобождена
        ```
        
        4. **Использование после освобождения:**
        ```c
        int *arr = malloc(100 * sizeof(int));
        free(arr);
        arr[0] = 10; // ОШИБКА! Память уже освобождена
        ```
        
        ## Резюме
        
        - Указатель хранит адрес переменной
        - & получает адрес, * разыменовывает
        - Указатели позволяют изменять переменные в функциях
        - Имя массива - указатель на первый элемент
        - malloc выделяет память, free освобождает
        - Всегда проверяйте указатели на NULL
        - Всегда освобождайте выделенную память
        - Указатели - мощный инструмент, но требуют осторожности!
        """;
    
    public static final String LESSON_5_STRINGS = """
        # Работа со строками в C
        
        ## Что такое строка?
        
        В C строка - это массив символов, заканчивающийся нулевым символом `\\0` (null terminator). Это не отдельный тип данных!
        
        ## Объявление строк
        
        ### Способ 1: Массив символов
        
        ```c
        char str[20] = "Hello";
        // Автоматически добавляется '\\0' в конец
        ```
        
        ### Способ 2: Указатель на строковый литерал
        
        ```c
        char *str = "Hello";
        // Строковые литералы неизменяемы!
        ```
        
        ### Способ 3: Инициализация посимвольно
        
        ```c
        char str[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};
        ```
        
        **Важно:** Не забудьте `\\0` в конце!
        
        ## Ввод и вывод строк
        
        ### printf и scanf
        
        ```c
        char name[50];
        printf("Введите имя: ");
        scanf("%s", name); // читает до пробела
        printf("Привет, %s!\\n", name);
        ```
        
        ### gets и puts (устаревшие, не рекомендуется)
        
        ```c
        char str[100];
        gets(str);  // читает всю строку (опасно!)
        puts(str);  // выводит строку с переводом строки
        ```
        
        ### fgets - безопасный ввод
        
        ```c
        char str[100];
        fgets(str, 100, stdin); // читает максимум 99 символов
        printf("%s", str);
        ```
        
        ## Стандартные функции для работы со строками
        
        Все функции находятся в `<string.h>`:
        
        ### strlen - длина строки
        
        ```c
        #include <string.h>
        
        char str[] = "Hello";
        int len = strlen(str); // 5 (без учета '\\0')
        ```
        
        ### strcpy - копирование
        
        ```c
        char src[] = "Hello";
        char dest[20];
        
        strcpy(dest, src); // копирует src в dest
        printf("%s\\n", dest); // Hello
        ```
        
        **Осторожно:** strcpy не проверяет размер! Используйте strncpy:
        ```c
        strncpy(dest, src, 19);
        dest[19] = '\\0'; // гарантируем завершение
        ```
        
        ### strcat - конкатенация (объединение)
        
        ```c
        char str1[20] = "Hello";
        char str2[] = " World";
        
        strcat(str1, str2);
        printf("%s\\n", str1); // Hello World
        ```
        
        ### strcmp - сравнение
        
        ```c
        char str1[] = "apple";
        char str2[] = "banana";
        
        int result = strcmp(str1, str2);
        // result < 0 если str1 < str2
        // result == 0 если str1 == str2
        // result > 0 если str1 > str2
        ```
        
        ### strchr - поиск символа
        
        ```c
        char str[] = "Hello";
        char *ptr = strchr(str, 'l'); // ищет первое вхождение 'l'
        
        if (ptr != NULL) {
            printf("Найдено на позиции %ld\\n", ptr - str); // 2
        }
        ```
        
        ### strstr - поиск подстроки
        
        ```c
        char str[] = "Hello World";
        char *ptr = strstr(str, "World");
        
        if (ptr != NULL) {
            printf("Найдено: %s\\n", ptr); // World
        }
        ```
        
        ## Создание собственных функций
        
        ### Длина строки (без strlen)
        
        ```c
        int myStrlen(char str[]) {
            int len = 0;
            while (str[len] != '\\0') {
                len++;
            }
            return len;
        }
        ```
        
        ### Копирование (без strcpy)
        
        ```c
        void myStrcpy(char dest[], char src[]) {
            int i = 0;
            while (src[i] != '\\0') {
                dest[i] = src[i];
                i++;
            }
            dest[i] = '\\0';
        }
        ```
        
        ### Объединение (без strcat)
        
        ```c
        void myStrcat(char dest[], char src[]) {
            int len = 0;
            while (dest[len] != '\\0') {
                len++;
            }
            
            int i = 0;
            while (src[i] != '\\0') {
                dest[len + i] = src[i];
                i++;
            }
            dest[len + i] = '\\0';
        }
        ```
        
        ## Перебор символов строки
        
        ```c
        char str[] = "Hello";
        
        // Способ 1: по индексу
        for (int i = 0; str[i] != '\\0'; i++) {
            printf("%c ", str[i]);
        }
        
        // Способ 2: через указатель
        char *ptr = str;
        while (*ptr != '\\0') {
            printf("%c ", *ptr);
            ptr++;
        }
        ```
        
        ## Модификация строк
        
        ```c
        char str[] = "Hello";
        
        str[0] = 'h'; // изменяем первый символ
        printf("%s\\n", str); // hello
        
        // Строковые литералы неизменяемы!
        char *ptr = "Hello";
        // ptr[0] = 'h'; // ОШИБКА! Приведет к краху
        ```
        
        ## Практические примеры
        
        ### Пример 1: Подсчет символов
        
        ```c
        #include <stdio.h>
        
        int countChars(char str[]) {
            int count = 0;
            while (str[count] != '\\0') {
                count++;
            }
            return count;
        }
        
        int main() {
            char str[] = "Hello";
            printf("Длина: %d\\n", countChars(str));
            return 0;
        }
        ```
        
        ### Пример 2: Поиск подстроки
        
        ```c
        int findSubstring(char str[], char substr[]) {
            int i = 0, j = 0;
            
            while (str[i] != '\\0') {
                if (str[i] == substr[j]) {
                    j++;
                    if (substr[j] == '\\0') {
                        return i - j + 1; // найдено
                    }
                } else {
                    j = 0;
                }
                i++;
            }
            return -1; // не найдено
        }
        ```
        
        ### Пример 3: Реверс строки
        
        ```c
        void reverseString(char str[]) {
            int len = 0;
            while (str[len] != '\\0') {
                len++;
            }
            
            for (int i = 0; i < len / 2; i++) {
                char temp = str[i];
                str[i] = str[len - 1 - i];
                str[len - 1 - i] = temp;
            }
        }
        ```
        
        ## Типичные ошибки
        
        1. **Забыли '\\0':**
        ```c
        char str[5] = {'H', 'e', 'l', 'l', 'o'}; // нет '\\0'!
        printf("%s\\n", str); // может вывести мусор
        ```
        
        2. **Выход за границы:**
        ```c
        char str[5] = "Hello"; // ОШИБКА! Нет места для '\\0'
        ```
        
        3. **Использование небезопасных функций:**
        ```c
        char str[10];
        gets(str); // ОПАСНО! Может переполнить буфер
        ```
        
        4. **Сравнение через ==:**
        ```c
        char str1[] = "Hello";
        char str2[] = "Hello";
        if (str1 == str2) { // ОШИБКА! Сравнивает адреса, не содержимое
        }
        // Правильно: if (strcmp(str1, str2) == 0)
        ```
        
        ## Резюме
        
        - Строка - массив символов с '\\0' в конце
        - strlen возвращает длину без '\\0'
        - strcpy копирует, strcat объединяет
        - strcmp сравнивает строки
        - Всегда оставляйте место для '\\0'
        - Используйте безопасные функции (fgets вместо gets)
        - Строковые литералы неизменяемы
        - Для сравнения используйте strcmp, не ==
        """;
    
    public static final String LESSON_6_CONDITIONS = """
        # Условные операторы в C
        
        ## Что такое условные операторы?
        
        Условные операторы позволяют программе принимать решения и выполнять разные действия в зависимости от условий. Это основа логики программирования.
        
        ## Оператор if
        
        Самый простой способ проверки условия.
        
        **Синтаксис:**
        ```c
        if (условие) {
            // код выполнится, если условие истинно (true)
        }
        ```
        
        **Пример:**
        ```c
        int age = 18;
        if (age >= 18) {
            printf("Вы совершеннолетний\\n");
        }
        ```
        
        ## Оператор if-else
        
        Выполняет один блок кода, если условие истинно, и другой - если ложно.
        
        **Синтаксис:**
        ```c
        if (условие) {
            // код если условие истинно
        } else {
            // код если условие ложно
        }
        ```
        
        **Пример:**
        ```c
        int number = 5;
        if (number % 2 == 0) {
            printf("Число четное\\n");
        } else {
            printf("Число нечетное\\n");
        }
        ```
        
        ## Оператор else-if
        
        Позволяет проверить несколько условий подряд.
        
        **Синтаксис:**
        ```c
        if (условие1) {
            // код 1
        } else if (условие2) {
            // код 2
        } else if (условие3) {
            // код 3
        } else {
            // код если ни одно условие не выполнено
        }
        ```
        
        **Пример:**
        ```c
        int score = 85;
        if (score >= 90) {
            printf("Отлично!\\n");
        } else if (score >= 70) {
            printf("Хорошо!\\n");
        } else if (score >= 50) {
            printf("Удовлетворительно\\n");
        } else {
            printf("Неудовлетворительно\\n");
        }
        ```
        
        ## Оператор switch
        
        Используется для выбора одного из многих вариантов на основе значения переменной.
        
        **Синтаксис:**
        ```c
        switch (переменная) {
            case значение1:
                // код для значение1
                break;
            case значение2:
                // код для значение2
                break;
            default:
                // код если ни одно значение не подошло
        }
        ```
        
        **Пример:**
        ```c
        int day = 3;
        switch (day) {
            case 1:
                printf("Понедельник\\n");
                break;
            case 2:
                printf("Вторник\\n");
                break;
            case 3:
                printf("Среда\\n");
                break;
            default:
                printf("Другой день\\n");
        }
        ```
        
        **Важно:** Не забудьте `break` после каждого `case`, иначе выполнение продолжится в следующем case!
        
        ## Логические операторы
        
        ### && (И)
        
        Возвращает true, если оба условия истинны.
        
        ```c
        int age = 20;
        int money = 1000;
        if (age >= 18 && money >= 500) {
            printf("Можно купить\\n");
        }
        ```
        
        ### || (ИЛИ)
        
        Возвращает true, если хотя бы одно условие истинно.
        
        ```c
        if (age < 18 || age > 65) {
            printf("Льготная категория\\n");
        }
        ```
        
        ### ! (НЕ)
        
        Инвертирует условие.
        
        ```c
        if (!isStudent) {
            printf("Не студент\\n");
        }
        ```
        
        ## Операторы сравнения
        
        - `==` - равно
        - `!=` - не равно
        - `>` - больше
        - `<` - меньше
        - `>=` - больше или равно
        - `<=` - меньше или равно
        
        **Пример:**
        ```c
        int a = 5, b = 10;
        
        if (a == b) printf("Равны\\n");
        if (a != b) printf("Не равны\\n");
        if (a < b) printf("a меньше b\\n");
        if (a > b) printf("a больше b\\n");
        ```
        
        ## Тернарный оператор
        
        Короткая форма if-else для простых случаев.
        
        **Синтаксис:**
        ```c
        переменная = условие ? значение_если_истина : значение_если_ложь;
        ```
        
        **Пример:**
        ```c
        int max = (a > b) ? a : b;  // выбирает большее из двух чисел
        ```
        
        Эквивалентно:
        ```c
        int max;
        if (a > b) {
            max = a;
        } else {
            max = b;
        }
        ```
        
        ## Вложенные условия
        
        Условия можно вкладывать друг в друга:
        
        ```c
        int age = 20;
        int money = 1000;
        
        if (age >= 18) {
            if (money >= 500) {
                printf("Можно купить\\n");
            } else {
                printf("Недостаточно денег\\n");
            }
        } else {
            printf("Слишком молодой\\n");
        }
        ```
        
        ## Практические примеры
        
        ### Пример 1: Определение знака числа
        
        ```c
        #include <stdio.h>
        
        int main() {
            int number;
            scanf("%d", &number);
            
            if (number > 0) {
                printf("Положительное\\n");
            } else if (number < 0) {
                printf("Отрицательное\\n");
            } else {
                printf("Ноль\\n");
            }
            
            return 0;
        }
        ```
        
        ### Пример 2: Калькулятор
        
        ```c
        #include <stdio.h>
        
        int main() {
            char operator;
            double a, b, result;
            
            scanf("%lf %c %lf", &a, &operator, &b);
            
            switch (operator) {
                case '+':
                    result = a + b;
                    break;
                case '-':
                    result = a - b;
                    break;
                case '*':
                    result = a * b;
                    break;
                case '/':
                    if (b != 0) {
                        result = a / b;
                    } else {
                        printf("Ошибка: деление на ноль!\\n");
                        return 1;
                    }
                    break;
                default:
                    printf("Неизвестная операция\\n");
                    return 1;
            }
            
            printf("Результат: %.2lf\\n", result);
            return 0;
        }
        ```
        
        ## Типичные ошибки
        
        1. **Использование = вместо ==:**
        ```c
        if (x = 5) {  // ОШИБКА! Присваивание вместо сравнения
            // всегда будет true
        }
        // Правильно: if (x == 5)
        ```
        
        2. **Забыли break в switch:**
        ```c
        switch (x) {
            case 1:
                printf("Один\\n");
                // забыли break - выполнится и case 2!
            case 2:
                printf("Два\\n");
                break;
        }
        ```
        
        3. **Сравнение строк через ==:**
        ```c
        char str1[] = "Hello";
        char str2[] = "Hello";
        if (str1 == str2) {  // ОШИБКА! Сравнивает адреса
            // всегда false
        }
        // Правильно: if (strcmp(str1, str2) == 0)
        ```
        
        ## Резюме
        
        - Используйте `if` для простых условий
        - Используйте `if-else` для двух вариантов
        - Используйте `else-if` для множественных условий
        - Используйте `switch` для выбора по значению
        - Всегда используйте `break` в `switch`
        - Используйте логические операторы для сложных условий
        - Тернарный оператор удобен для простых присваиваний
        - Будьте осторожны с `=` и `==`
        """;
    
    public static final String LESSON_7_STRUCTS = """
        # Структуры данных в C
        
        ## Что такое структура?
        
        Структура (struct) - это пользовательский тип данных, который позволяет объединить несколько переменных разных типов под одним именем. Это основа объектно-ориентированного подхода в C.
        
        ## Объявление структуры
        
        **Синтаксис:**
        ```c
        struct имя_структуры {
            тип1 поле1;
            тип2 поле2;
            // ...
        };
        ```
        
        **Пример:**
        ```c
        struct Student {
            char name[50];
            int age;
            float gpa;
        };
        ```
        
        ## Создание переменных структуры
        
        ```c
        struct Student student1;
        struct Student student2;
        ```
        
        Или при объявлении:
        ```c
        struct Student {
            char name[50];
            int age;
            float gpa;
        } student1, student2;
        ```
        
        ## Доступ к полям
        
        Используется оператор точка (`.`):
        
        ```c
        struct Student student1;
        
        strcpy(student1.name, "Иван");
        student1.age = 20;
        student1.gpa = 4.5;
        
        printf("Имя: %s, Возраст: %d, GPA: %.2f\\n", 
               student1.name, student1.age, student1.gpa);
        ```
        
        ## Инициализация структуры
        
        ```c
        struct Student student1 = {"Иван", 20, 4.5};
        
        // Или по полям
        struct Student student2 = {
            .name = "Мария",
            .age = 19,
            .gpa = 4.8
        };
        ```
        
        ## typedef - создание псевдонимов
        
        `typedef` позволяет создать более короткое имя для структуры:
        
        ```c
        typedef struct {
            char name[50];
            int age;
            float gpa;
        } Student;
        
        // Теперь можно использовать без слова struct
        Student student1;
        Student student2;
        ```
        
        ## Массивы структур
        
        Можно создавать массивы структур:
        
        ```c
        struct Student students[10];
        
        for (int i = 0; i < 10; i++) {
            printf("Введите имя студента %d: ", i + 1);
            scanf("%s", students[i].name);
            printf("Введите возраст: ");
            scanf("%d", &students[i].age);
        }
        ```
        
        ## Структуры и функции
        
        ### Передача структуры в функцию
        
        ```c
        void printStudent(struct Student s) {
            printf("Имя: %s, Возраст: %d, GPA: %.2f\\n", 
                   s.name, s.age, s.gpa);
        }
        
        int main() {
            struct Student student = {"Иван", 20, 4.5};
            printStudent(student);
            return 0;
        }
        ```
        
        **Важно:** При передаче структуры по значению создается копия!
        
        ### Передача указателя на структуру
        
        Более эффективный способ:
        
        ```c
        void printStudent(struct Student *s) {
            printf("Имя: %s, Возраст: %d, GPA: %.2f\\n", 
                   s->name, s->age, s->gpa);
        }
        
        int main() {
            struct Student student = {"Иван", 20, 4.5};
            printStudent(&student);
            return 0;
        }
        ```
        
        **Оператор `->`** используется для доступа к полям через указатель.
        
        ## Вложенные структуры
        
        Структуры могут содержать другие структуры:
        
        ```c
        struct Date {
            int day;
            int month;
            int year;
        };
        
        struct Person {
            char name[50];
            struct Date birthDate;
            int age;
        };
        
        struct Person person = {
            .name = "Иван",
            .birthDate = {15, 5, 2000},
            .age = 23
        };
        
        printf("Дата рождения: %d.%d.%d\\n", 
               person.birthDate.day, 
               person.birthDate.month, 
               person.birthDate.year);
        ```
        
        ## Практические примеры
        
        ### Пример 1: Точка на плоскости
        
        ```c
        #include <stdio.h>
        #include <math.h>
        
        typedef struct {
            double x;
            double y;
        } Point;
        
        double distance(Point p1, Point p2) {
            double dx = p2.x - p1.x;
            double dy = p2.y - p1.y;
            return sqrt(dx * dx + dy * dy);
        }
        
        int main() {
            Point p1 = {0, 0};
            Point p2 = {3, 4};
            
            printf("Расстояние: %.2f\\n", distance(p1, p2));
            return 0;
        }
        ```
        
        ### Пример 2: Книга
        
        ```c
        typedef struct {
            char title[100];
            char author[50];
            int year;
            float price;
        } Book;
        
        void printBook(Book *book) {
            printf("Название: %s\\n", book->title);
            printf("Автор: %s\\n", book->author);
            printf("Год: %d\\n", book->year);
            printf("Цена: %.2f\\n", book->price);
        }
        
        int main() {
            Book book = {
                .title = "Язык C",
                .author = "Керниган и Ритчи",
                .year = 1978,
                .price = 1500.0
            };
            
            printBook(&book);
            return 0;
        }
        ```
        
        ## Типичные ошибки
        
        1. **Забыли точку с запятой после объявления:**
        ```c
        struct Student {
            char name[50];
            int age;
        }  // ОШИБКА! Нужна точка с запятой
        ```
        
        2. **Использование . вместо -> с указателем:**
        ```c
        struct Student *s;
        s.name = "Иван";  // ОШИБКА!
        s->name = "Иван"; // Правильно
        ```
        
        3. **Копирование строк через =:**
        ```c
        struct Student s;
        s.name = "Иван";  // ОШИБКА!
        strcpy(s.name, "Иван"); // Правильно
        ```
        
        ## Резюме
        
        - Структуры объединяют разные типы данных
        - Используйте `.` для доступа к полям
        - Используйте `->` для доступа через указатель
        - `typedef` создает удобные псевдонимы
        - Структуры можно вкладывать друг в друга
        - Передавайте структуры по указателю для эффективности
        - Структуры - основа для создания сложных типов данных
        """;
    
    public static final String LESSON_8_FILES = """
        # Работа с файлами в C
        
        ## Введение
        
        Работа с файлами позволяет программе сохранять данные на диск и читать их обратно. Это необходимо для создания программ, которые работают с постоянными данными.
        
        ## Открытие файла
        
        Используется функция `fopen()`:
        
        **Синтаксис:**
        ```c
        FILE *fopen(const char *filename, const char *mode);
        ```
        
        **Режимы открытия:**
        - `"r"` - чтение (read)
        - `"w"` - запись (write, создает новый файл или перезаписывает существующий)
        - `"a"` - добавление (append, добавляет в конец файла)
        - `"r+"` - чтение и запись
        - `"w+"` - чтение и запись (создает новый файл)
        - `"a+"` - чтение и добавление
        
        **Пример:**
        ```c
        #include <stdio.h>
        
        FILE *file = fopen("data.txt", "r");
        if (file == NULL) {
            printf("Ошибка открытия файла!\\n");
            return 1;
        }
        // работа с файлом
        fclose(file);
        ```
        
        **Важно:** Всегда проверяйте результат `fopen()` на `NULL`!
        
        ## Закрытие файла
        
        Используется функция `fclose()`:
        
        ```c
        fclose(file);
        ```
        
        **Важно:** Всегда закрывайте файлы после работы с ними!
        
        ## Чтение из файла
        
        ### fgetc() - чтение одного символа
        
        ```c
        FILE *file = fopen("data.txt", "r");
        if (file == NULL) {
            printf("Ошибка!\\n");
            return 1;
        }
        
        int ch;
        while ((ch = fgetc(file)) != EOF) {
            printf("%c", ch);
        }
        
        fclose(file);
        ```
        
        ### fgets() - чтение строки
        
        ```c
        FILE *file = fopen("data.txt", "r");
        char line[100];
        
        while (fgets(line, sizeof(line), file) != NULL) {
            printf("%s", line);
        }
        
        fclose(file);
        ```
        
        ### fscanf() - форматированное чтение
        
        ```c
        FILE *file = fopen("data.txt", "r");
        int number;
        char name[50];
        
        while (fscanf(file, "%d %s", &number, name) == 2) {
            printf("Число: %d, Имя: %s\\n", number, name);
        }
        
        fclose(file);
        ```
        
        ## Запись в файл
        
        ### fputc() - запись одного символа
        
        ```c
        FILE *file = fopen("output.txt", "w");
        if (file == NULL) {
            printf("Ошибка!\\n");
            return 1;
        }
        
        fputc('A', file);
        fputc('\\n', file);
        
        fclose(file);
        ```
        
        ### fputs() - запись строки
        
        ```c
        FILE *file = fopen("output.txt", "w");
        fputs("Привет, мир!\\n", file);
        fclose(file);
        ```
        
        ### fprintf() - форматированная запись
        
        ```c
        FILE *file = fopen("output.txt", "w");
        int age = 20;
        char name[] = "Иван";
        
        fprintf(file, "Имя: %s, Возраст: %d\\n", name, age);
        fclose(file);
        ```
        
        ## Проверка конца файла
        
        Используется функция `feof()`:
        
        ```c
        FILE *file = fopen("data.txt", "r");
        int ch;
        
        while (!feof(file)) {
            ch = fgetc(file);
            if (ch != EOF) {
                printf("%c", ch);
            }
        }
        
        fclose(file);
        ```
        
        ## Обработка ошибок
        
        ```c
        FILE *file = fopen("data.txt", "r");
        if (file == NULL) {
            perror("Ошибка открытия файла");
            return 1;
        }
        
        // работа с файлом
        
        if (fclose(file) != 0) {
            perror("Ошибка закрытия файла");
            return 1;
        }
        ```
        
        ## Практические примеры
        
        ### Пример 1: Копирование файла
        
        ```c
        #include <stdio.h>
        
        int main() {
            FILE *source = fopen("source.txt", "r");
            FILE *dest = fopen("dest.txt", "w");
            
            if (source == NULL || dest == NULL) {
                printf("Ошибка открытия файлов!\\n");
                return 1;
            }
            
            int ch;
            while ((ch = fgetc(source)) != EOF) {
                fputc(ch, dest);
            }
            
            fclose(source);
            fclose(dest);
            
            printf("Файл скопирован!\\n");
            return 0;
        }
        ```
        
        ### Пример 2: Подсчет строк в файле
        
        ```c
        #include <stdio.h>
        
        int main() {
            FILE *file = fopen("data.txt", "r");
            if (file == NULL) {
                printf("Ошибка!\\n");
                return 1;
            }
            
            int lines = 0;
            char line[1000];
            
            while (fgets(line, sizeof(line), file) != NULL) {
                lines++;
            }
            
            printf("Количество строк: %d\\n", lines);
            fclose(file);
            return 0;
        }
        ```
        
        ### Пример 3: Чтение чисел из файла
        
        ```c
        #include <stdio.h>
        
        int main() {
            FILE *file = fopen("numbers.txt", "r");
            if (file == NULL) {
                printf("Ошибка!\\n");
                return 1;
            }
            
            int number, sum = 0, count = 0;
            
            while (fscanf(file, "%d", &number) == 1) {
                sum += number;
                count++;
            }
            
            if (count > 0) {
                printf("Сумма: %d\\n", sum);
                printf("Среднее: %.2f\\n", (double)sum / count);
            }
            
            fclose(file);
            return 0;
        }
        ```
        
        ## Типичные ошибки
        
        1. **Не проверили результат fopen():**
        ```c
        FILE *file = fopen("data.txt", "r");
        // ОШИБКА! file может быть NULL
        fgetc(file); // крах программы!
        ```
        
        2. **Забыли закрыть файл:**
        ```c
        FILE *file = fopen("data.txt", "r");
        // работа с файлом
        // забыли fclose(file) - утечка ресурсов!
        ```
        
        3. **Использование неправильного режима:**
        ```c
        FILE *file = fopen("data.txt", "w");
        fgetc(file); // ОШИБКА! Файл открыт только для записи
        ```
        
        ## Резюме
        
        - Всегда проверяйте результат `fopen()` на `NULL`
        - Всегда закрывайте файлы через `fclose()`
        - Используйте правильные режимы открытия
        - `fgetc()` читает символ, `fputc()` записывает
        - `fgets()` читает строку, `fputs()` записывает
        - `fscanf()` и `fprintf()` для форматированного ввода/вывода
        - Используйте `feof()` для проверки конца файла
        - Обрабатывайте ошибки через `perror()`
        """;
}

