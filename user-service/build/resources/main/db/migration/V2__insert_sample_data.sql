-- Вставка тестовых данных: уроки, навыки и задачи
-- Примечание: Этот скрипт работает только с PostgreSQL
-- Для H2 используйте DataInitializer класс

-- Сначала создаем тестового пользователя-преподавателя (если его нет)
-- ID будет сгенерирован автоматически, но нам нужен фиксированный для связей
-- В реальной системе лучше использовать DataInitializer

-- Создаем навыки
INSERT INTO skills (id, name, description, max_level, created_at, updated_at)
VALUES 
    ('00000000-0000-0000-0000-000000000001', 'Циклы', 'Работа с циклами for, while, do-while', 10, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
    ('00000000-0000-0000-0000-000000000002', 'Массивы', 'Работа с одномерными и многомерными массивами', 10, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
    ('00000000-0000-0000-0000-000000000003', 'Функции', 'Создание и использование функций', 10, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
    ('00000000-0000-0000-0000-000000000004', 'Указатели', 'Работа с указателями и динамической памятью', 10, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
    ('00000000-0000-0000-0000-000000000005', 'Строки', 'Работа со строками в C', 10, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT (id) DO NOTHING;

-- Создаем уроки (нужен created_by, используем первый доступный ID или NULL)
-- В реальной системе лучше использовать DataInitializer для правильных связей
INSERT INTO lessons (id, title, description, content, topic, order_number, created_by, published, created_at, updated_at)
VALUES 
    ('10000000-0000-0000-0000-000000000001', 'Введение в циклы', 
     'Изучите основы работы с циклами в языке C', 
     'Циклы позволяют выполнять один и тот же блок кода несколько раз. В C есть три типа циклов:\n\n1. for - используется когда известно количество итераций\n2. while - выполняется пока условие истинно\n3. do-while - выполняется хотя бы один раз, затем проверяет условие\n\nПример цикла for:\nfor (int i = 0; i < 10; i++) {\n    printf("%d\\n", i);\n}',
     'Циклы', 1, NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('10000000-0000-0000-0000-000000000002', 'Работа с массивами',
     'Изучите как работать с массивами в C',
     'Массив - это набор элементов одного типа, расположенных в памяти последовательно.\n\nОбъявление массива:\nint arr[10]; // массив из 10 целых чисел\n\nДоступ к элементам:\narr[0] = 5; // первый элемент\narr[9] = 10; // последний элемент\n\nМассивы индексируются с нуля!',
     'Массивы', 2, NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('10000000-0000-0000-0000-000000000003', 'Функции в C',
     'Научитесь создавать и использовать функции',
     'Функция - это блок кода, который выполняет определенную задачу.\n\nОбъявление функции:\nint add(int a, int b) {\n    return a + b;\n}\n\nВызов функции:\nint result = add(5, 3); // result = 8\n\nФункции помогают:\n- Организовать код\n- Избежать дублирования\n- Упростить отладку',
     'Функции', 3, NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('10000000-0000-0000-0000-000000000004', 'Указатели',
     'Изучите работу с указателями',
     'Указатель - это переменная, которая хранит адрес другой переменной.\n\nОбъявление указателя:\nint *ptr;\n\nПолучение адреса:\nint x = 10;\nptr = &x; // ptr теперь содержит адрес x\n\nРазыменование:\n*ptr = 20; // изменяет значение x на 20',
     'Указатели', 4, NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('10000000-0000-0000-0000-000000000005', 'Работа со строками',
     'Научитесь работать со строками в C',
     'В C строки - это массивы символов, заканчивающиеся нулевым символом \\0.\n\nОбъявление строки:\nchar str[100] = "Hello";\n\nФункции для работы со строками:\n- strlen(str) - длина строки\n- strcpy(dest, src) - копирование\n- strcat(dest, src) - конкатенация\n- strcmp(str1, str2) - сравнение',
     'Строки', 5, NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT (id) DO NOTHING;

-- Создаем задачи
INSERT INTO tasks (id, title, description, code_template, test_cases, xp_reward, difficulty, lesson_id, skill_id, created_by, published, created_at, updated_at)
VALUES 
    -- Легкие задачи
    ('20000000-0000-0000-0000-000000000001', 'Сумма чисел от 1 до N',
     'Напишите программу, которая вычисляет сумму всех чисел от 1 до N включительно.\n\nВходные данные: одно целое число N (1 ≤ N ≤ 1000)\nВыходные данные: сумма чисел от 1 до N\n\nПример:\nВход: 5\nВыход: 15 (1+2+3+4+5=15)',
     '#include <stdio.h>\n\nint main() {\n    int n;\n    scanf("%d", &n);\n    \n    // Ваш код здесь\n    \n    return 0;\n}',
     '{"tests": [{"input": "5", "output": "15"}, {"input": "10", "output": "55"}, {"input": "100", "output": "5050"}]}',
     10, 'EASY', '10000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000001', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('20000000-0000-0000-0000-000000000002', 'Факториал числа',
     'Вычислите факториал числа N. Факториал N (обозначается N!) - это произведение всех натуральных чисел от 1 до N.\n\nВходные данные: одно целое число N (0 ≤ N ≤ 10)\nВыходные данные: факториал числа N\n\nПример:\nВход: 5\nВыход: 120 (5! = 1*2*3*4*5 = 120)\n\nПримечание: 0! = 1',
     '#include <stdio.h>\n\nint main() {\n    int n;\n    scanf("%d", &n);\n    \n    // Ваш код здесь\n    \n    return 0;\n}',
     '{"tests": [{"input": "5", "output": "120"}, {"input": "0", "output": "1"}, {"input": "7", "output": "5040"}]}',
     15, 'EASY', '10000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000001', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('20000000-0000-0000-0000-000000000003', 'Максимальный элемент массива',
     'Найдите максимальный элемент в массиве из N целых чисел.\n\nВходные данные:\nПервая строка: N (1 ≤ N ≤ 1000) - размер массива\nВторая строка: N целых чисел через пробел\n\nВыходные данные: максимальный элемент\n\nПример:\nВход:\n5\n3 7 2 9 1\nВыход: 9',
     '#include <stdio.h>\n\nint main() {\n    int n;\n    scanf("%d", &n);\n    int arr[1000];\n    \n    // Ваш код здесь\n    \n    return 0;\n}',
     '{"tests": [{"input": "5\\n3 7 2 9 1", "output": "9"}, {"input": "3\\n-5 -2 -10", "output": "-2"}]}',
     15, 'EASY', '10000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-000000000002', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('20000000-0000-0000-0000-000000000004', 'Сумма элементов массива',
     'Вычислите сумму всех элементов массива.\n\nВходные данные:\nПервая строка: N (1 ≤ N ≤ 1000) - размер массива\nВторая строка: N целых чисел через пробел\n\nВыходные данные: сумма всех элементов\n\nПример:\nВход:\n4\n1 2 3 4\nВыход: 10',
     '#include <stdio.h>\n\nint main() {\n    int n;\n    scanf("%d", &n);\n    int arr[1000];\n    \n    // Ваш код здесь\n    \n    return 0;\n}',
     '{"tests": [{"input": "4\\n1 2 3 4", "output": "10"}, {"input": "3\\n-5 10 -3", "output": "2"}]}',
     10, 'EASY', '10000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-000000000002', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    -- Средние задачи
    ('20000000-0000-0000-0000-000000000005', 'Функция для вычисления степени',
     'Напишите функцию power(int base, int exponent), которая вычисляет base в степени exponent.\n\nВходные данные: два целых числа base и exponent (0 ≤ exponent ≤ 10)\nВыходные данные: base^exponent\n\nПример:\nВход: 2 3\nВыход: 8 (2^3 = 8)\n\nПримечание: base^0 = 1 для любого base',
     '#include <stdio.h>\n\n// Ваша функция здесь\n\nint main() {\n    int base, exponent;\n    scanf("%d %d", &base, &exponent);\n    \n    // Вызовите вашу функцию и выведите результат\n    \n    return 0;\n}',
     '{"tests": [{"input": "2 3", "output": "8"}, {"input": "5 0", "output": "1"}, {"input": "3 4", "output": "81"}]}',
     20, 'MEDIUM', '10000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-000000000003', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('20000000-0000-0000-0000-000000000006', 'Проверка на простое число',
     'Напишите функцию isPrime(int n), которая проверяет, является ли число простым.\n\nПростое число - это число, которое делится только на 1 и на само себя.\n\nВходные данные: одно целое число N (2 ≤ N ≤ 1000)\nВыходные данные: 1 если число простое, 0 если составное\n\nПример:\nВход: 7\nВыход: 1\n\nВход: 10\nВыход: 0',
     '#include <stdio.h>\n\n// Ваша функция isPrime здесь\n\nint main() {\n    int n;\n    scanf("%d", &n);\n    \n    // Вызовите isPrime и выведите результат\n    \n    return 0;\n}',
     '{"tests": [{"input": "7", "output": "1"}, {"input": "10", "output": "0"}, {"input": "17", "output": "1"}]}',
     25, 'MEDIUM', '10000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-000000000003', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('20000000-0000-0000-0000-000000000007', 'Обратный массив',
     'Напишите программу, которая переворачивает массив (первый элемент становится последним и наоборот).\n\nВходные данные:\nПервая строка: N (1 ≤ N ≤ 1000) - размер массива\nВторая строка: N целых чисел через пробел\n\nВыходные данные: элементы массива в обратном порядке через пробел\n\nПример:\nВход:\n5\n1 2 3 4 5\nВыход: 5 4 3 2 1',
     '#include <stdio.h>\n\nint main() {\n    int n;\n    scanf("%d", &n);\n    int arr[1000];\n    \n    // Ваш код здесь\n    \n    return 0;\n}',
     '{"tests": [{"input": "5\\n1 2 3 4 5", "output": "5 4 3 2 1"}, {"input": "3\\n10 20 30", "output": "30 20 10"}]}',
     20, 'MEDIUM', '10000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-000000000002', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('20000000-0000-0000-0000-000000000008', 'Подсчет символов в строке',
     'Напишите программу, которая подсчитывает количество символов в строке (без использования strlen).\n\nВходные данные: строка (максимум 1000 символов)\nВыходные данные: количество символов в строке\n\nПример:\nВход: Hello\nВыход: 5',
     '#include <stdio.h>\n\nint main() {\n    char str[1001];\n    scanf("%s", str);\n    \n    // Ваш код здесь\n    \n    return 0;\n}',
     '{"tests": [{"input": "Hello", "output": "5"}, {"input": "C", "output": "1"}]}',
     15, 'MEDIUM', '10000000-0000-0000-0000-000000000005', '00000000-0000-0000-0000-000000000005', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    -- Сложные задачи
    ('20000000-0000-0000-0000-000000000009', 'Обмен значений через указатели',
     'Напишите функцию swap(int *a, int *b), которая меняет местами значения двух переменных, используя указатели.\n\nВходные данные: два целых числа\nВыходные данные: те же числа, но в обратном порядке\n\nПример:\nВход: 5 10\nВыход: 10 5',
     '#include <stdio.h>\n\n// Ваша функция swap здесь\n\nint main() {\n    int a, b;\n    scanf("%d %d", &a, &b);\n    \n    // Вызовите swap и выведите результат\n    \n    return 0;\n}',
     '{"tests": [{"input": "5 10", "output": "10 5"}, {"input": "-3 7", "output": "7 -3"}]}',
     30, 'HARD', '10000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-000000000004', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('20000000-0000-0000-0000-000000000010', 'Поиск подстроки',
     'Напишите функцию, которая ищет подстроку в строке и возвращает индекс первого вхождения, или -1 если подстрока не найдена.\n\nВходные данные:\nПервая строка: основная строка\nВторая строка: подстрока для поиска\n\nВыходные данные: индекс первого вхождения или -1\n\nПример:\nВход:\nHello World\nWorld\nВыход: 6',
     '#include <stdio.h>\n\n// Ваша функция поиска здесь\n\nint main() {\n    char str[1001], substr[1001];\n    scanf("%s", str);\n    scanf("%s", substr);\n    \n    // Ваш код здесь\n    \n    return 0;\n}',
     '{"tests": [{"input": "Hello\\nWorld", "output": "-1"}, {"input": "programming\\nram", "output": "2"}]}',
     35, 'HARD', '10000000-0000-0000-0000-000000000005', '00000000-0000-0000-0000-000000000005', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('20000000-0000-0000-0000-000000000011', 'Сортировка массива',
     'Отсортируйте массив целых чисел по возрастанию (используйте любой алгоритм сортировки).\n\nВходные данные:\nПервая строка: N (1 ≤ N ≤ 1000) - размер массива\nВторая строка: N целых чисел через пробел\n\nВыходные данные: отсортированный массив\n\nПример:\nВход:\n5\n3 1 4 2 5\nВыход: 1 2 3 4 5',
     '#include <stdio.h>\n\nint main() {\n    int n;\n    scanf("%d", &n);\n    int arr[1000];\n    \n    // Ваш код здесь\n    \n    return 0;\n}',
     '{"tests": [{"input": "5\\n3 1 4 2 5", "output": "1 2 3 4 5"}, {"input": "4\\n10 5 20 1", "output": "1 5 10 20"}]}',
     30, 'HARD', '10000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-000000000002', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    -- Экспертные задачи
    ('20000000-0000-0000-0000-000000000012', 'Двоичный поиск',
     'Реализуйте алгоритм двоичного поиска в отсортированном массиве.\n\nВходные данные:\nПервая строка: N (1 ≤ N ≤ 1000) - размер отсортированного массива\nВторая строка: N целых чисел в порядке возрастания\nТретья строка: число для поиска\n\nВыходные данные: индекс найденного элемента или -1\n\nПример:\nВход:\n5\n1 3 5 7 9\n5\nВыход: 2',
     '#include <stdio.h>\n\n// Ваша функция binarySearch здесь\n\nint main() {\n    int n, target;\n    scanf("%d", &n);\n    int arr[1000];\n    \n    // Ваш код здесь\n    \n    return 0;\n}',
     '{"tests": [{"input": "5\\n1 3 5 7 9\\n5", "output": "2"}, {"input": "4\\n2 4 6 8\\n3", "output": "-1"}]}',
     50, 'EXPERT', '10000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-000000000002', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
     
    ('20000000-0000-0000-0000-000000000013', 'Работа с динамической памятью',
     'Напишите программу, которая создает динамический массив, заполняет его числами от 1 до N, и выводит сумму элементов.\n\nВходные данные: одно целое число N (1 ≤ N ≤ 1000)\nВыходные данные: сумма элементов массива\n\nПример:\nВход: 5\nВыход: 15\n\nПримечание: не забудьте освободить память!',
     '#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf("%d", &n);\n    \n    // Ваш код здесь (используйте malloc и free)\n    \n    return 0;\n}',
     '{"tests": [{"input": "5", "output": "15"}, {"input": "10", "output": "55"}]}',
     40, 'EXPERT', '10000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-000000000004', NULL, true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT (id) DO NOTHING;

